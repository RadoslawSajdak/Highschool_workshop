<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>GPIO | </title>
<meta name=keywords content>
<meta name=description content="GPIO (General-Purpose Input Output) Obsługa wielu wyjść cyfrowych Po ukończeniu wprowadzenia, wiesz już jak zamrugać diodą. Każda dioda, ma katodę (-) oraz anodę (+). Anoda, posiada krótszą nóżkę i to do niej należy podłączyć zasilanie. Można skojarzyć to prez znaną nazwę AK47 (prąd płynie A -> K, a 4 jest mniejsze niż 7 :)). Dodatkowo, aby ograniczyć prąd płynący przez diodę, należy szeregowo włączyć do niej rezystor. Podobnie jak na poniższym obrazku, podłącz trzy diody do pinów D5, D6, D7.">
<meta name=author content="Radosław Sajdak">
<link rel=canonical href=https://radoslawsajdak.github.io/post/gpio/>
<link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://radoslawsajdak.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://radoslawsajdak.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://radoslawsajdak.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://radoslawsajdak.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://radoslawsajdak.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="GPIO">
<meta property="og:description" content="GPIO (General-Purpose Input Output) Obsługa wielu wyjść cyfrowych Po ukończeniu wprowadzenia, wiesz już jak zamrugać diodą. Każda dioda, ma katodę (-) oraz anodę (+). Anoda, posiada krótszą nóżkę i to do niej należy podłączyć zasilanie. Można skojarzyć to prez znaną nazwę AK47 (prąd płynie A -> K, a 4 jest mniejsze niż 7 :)). Dodatkowo, aby ograniczyć prąd płynący przez diodę, należy szeregowo włączyć do niej rezystor. Podobnie jak na poniższym obrazku, podłącz trzy diody do pinów D5, D6, D7.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://radoslawsajdak.github.io/post/gpio/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2023-02-13T16:35:29+01:00">
<meta property="article:modified_time" content="2023-02-13T16:35:29+01:00"><meta property="og:site_name" content="true">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="GPIO">
<meta name=twitter:description content="GPIO (General-Purpose Input Output) Obsługa wielu wyjść cyfrowych Po ukończeniu wprowadzenia, wiesz już jak zamrugać diodą. Każda dioda, ma katodę (-) oraz anodę (+). Anoda, posiada krótszą nóżkę i to do niej należy podłączyć zasilanie. Można skojarzyć to prez znaną nazwę AK47 (prąd płynie A -> K, a 4 jest mniejsze niż 7 :)). Dodatkowo, aby ograniczyć prąd płynący przez diodę, należy szeregowo włączyć do niej rezystor. Podobnie jak na poniższym obrazku, podłącz trzy diody do pinów D5, D6, D7.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://radoslawsajdak.github.io/post/"},{"@type":"ListItem","position":2,"name":"GPIO","item":"https://radoslawsajdak.github.io/post/gpio/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GPIO","name":"GPIO","description":"GPIO (General-Purpose Input Output) Obsługa wielu wyjść cyfrowych Po ukończeniu wprowadzenia, wiesz już jak zamrugać diodą. Każda dioda, ma katodę (-) oraz anodę (+). Anoda, posiada krótszą nóżkę i to do niej należy podłączyć zasilanie. Można skojarzyć to prez znaną nazwę AK47 (prąd płynie A -\u0026gt; K, a 4 jest mniejsze niż 7 :)). Dodatkowo, aby ograniczyć prąd płynący przez diodę, należy szeregowo włączyć do niej rezystor. Podobnie jak na poniższym obrazku, podłącz trzy diody do pinów D5, D6, D7.","keywords":[],"articleBody":"GPIO (General-Purpose Input Output) Obsługa wielu wyjść cyfrowych Po ukończeniu wprowadzenia, wiesz już jak zamrugać diodą. Każda dioda, ma katodę (-) oraz anodę (+). Anoda, posiada krótszą nóżkę i to do niej należy podłączyć zasilanie. Można skojarzyć to prez znaną nazwę AK47 (prąd płynie A - K, a 4 jest mniejsze niż 7 :)). Dodatkowo, aby ograniczyć prąd płynący przez diodę, należy szeregowo włączyć do niej rezystor. Podobnie jak na poniższym obrazku, podłącz trzy diody do pinów D5, D6, D7.\nPokaż rozwiązanie   Wiedząc, że\ndigitalWrite(PIN_NUMBER, LOGIC_LEVEL); oraz\npinMode(PIN_NUMBER, LOGIC_LEVEL); spróbuj zamrugać trzema diodami po kolei.\n#include \"Arduino.h\" #define LED_PIN1 D6 #define LED_PIN2 D7 #define LED_PIN3 D8 #define LED_BLINK_PERIOD 1000 void setup() { pinMode(LED_PIN1, OUTPUT); pinMode(LED_PIN2, OUTPUT); pinMode(LED_PIN3, OUTPUT); } void loop() { digitalWrite(LED_PIN1, HIGH); delay(LED_BLINK_PERIOD); digitalWrite(LED_PIN1, LOW); delay(LED_BLINK_PERIOD); digitalWrite(LED_PIN2, HIGH); delay(LED_BLINK_PERIOD); digitalWrite(LED_PIN2, LOW); delay(LED_BLINK_PERIOD); digitalWrite(LED_PIN3, HIGH); delay(LED_BLINK_PERIOD); digitalWrite(LED_PIN3, LOW); delay(LED_BLINK_PERIOD); }  Pokaż rozwiązanie   Funkcja, mrugająca diodą Aby uniknąć powielania kodu, co zrobiliśmy powyżej, tworzymy funkcje. W językach o typie statycznym (C, C++) mają zazwyczaj format [typ zwracany] nazwa_funkcji(typ argumentu1, typ argumentu2){ [Kod tutaj] }.\nTypy, różnią się od siebie rozmiarem. Wyjątkiem, jest typ void który informuje nas, że funkcja nie zwraca niczego.\nSpróbuj napisać funkcję mrugającą diodą:\n o nazwie blinkLED zwracającą void przyjmującą jeden argument typu uint8_t.  Na ten moment przyjmijmy, że funkcje znajdują się powyżej\nvoid setup() { } void blinkLED(uint8_t ledNo) { digitalWrite(ledNo, HIGH); delay(LED_BLINK_PERIOD); digitalWrite(ledNo, LOW); delay(LED_BLINK_PERIOD); }  Pokaż rozwiązanie   Używając napisanej przez Ciebie funkcji, popraw nasz wcześniejszy przykład.\nvoid loop() { blinkLED(LED_PIN1); blinkLED(LED_PIN2); blinkLED(LED_PIN3); }  Pokaż rozwiązanie   Sterowanie jasnością LED - PWM (Pulse Width Modulation) Każdy z naszych pinów, może pracować w różnych trybach. Jednym z nich jest PWM, czyli modulacja wypełnieniem sygnału. Upraszczając, możemy sterować tym jaki procent czasu pin jest w stanie wysokim, a jaki w niskim. Służy do tego funkcja\nanalogWrite(PIN_NUMBER, VALUE(0-255)); Dodatkowe informacje znajdziesz w:\n Dokumentacji biblioteki arduino link Krótkim tutorialu o PWM link  Spróbuj uruchomić na swojej płytce poniższy kod. Czy LED zmienia jasność krokowo?\nvoid loop(){ analogWrite(LED_PIN1, 50); delay(LED_BLINK_PERIOD); analogWrite(LED_PIN1, 150); delay(LED_BLINK_PERIOD); analogWrite(LED_PIN1, 250); delay(LED_BLINK_PERIOD); } Narastająca jasność - pętle Chcąc aby nasz LED rozjaśniał się płynnie, musielibyśmy 255 razy wywołać funkcję analogWrite(). Nie byłoby to jednak ani czytelne, ani wydajne. Służą do tego pętle. Pozwalają one na wywołanie jakiegoś fragmentu kodu, ściśle określoną ilość razy. W C, używamy trzech pętli:\n do{ [kod] }while(warunek) while(warunek){ [kod] } for(iterator; warunek; instrukcja){ [kod] }  Każda z nich, działa w trochę różny sposób.\n do{ [kod] }while(warunek), sprawdza warunek po wyjściu z bloku kodu while(warunek){ [kod] }, sprawdza warunek przed wejściem do bloku kodu for(iterator; warunek; instrukcja){ [kod] } może stworzyć element (np. iterator), sprawdza warunek przed wejściem, ale również wykonuje jakąś instrukcje (np. dodawanie) po wyjściu z bloku.  Używany przez nas\nvoid loop() { } To nic innego jak\nwhile(1) { } W naszych przykładach, będziemy używać głównie pętli for. Jest ona najwygodniejsza w użyciu, ponieważ pozwala wykonać wszystkie niezbędne operacje związane z pętlami w przejrzysty sposób.\nWięcej o pętli for, możesz przeczytać tutaj\nSpróbuj napisać funkcję fadeIn(), która będzie rozjaśniać diodę led w sposób płynny. Użyj do tego pętli\nfor(uint8_t i = 0; i  255; i++) { } UWAGA! Ze względu na charakterystykę diody, wyższe wartości i mogą nie wpływać wyraźnie na jasność diody, jednak bez problemu zaobserwujesz rozjaśnianie.\n#include \"Arduino.h\" #define LED_PIN1 D6 #define LED_PIN2 D7 #define LED_PIN3 D8 #define LED_BLINK_PERIOD 1000 void setup() { pinMode(LED_PIN1, OUTPUT); pinMode(LED_PIN2, OUTPUT); pinMode(LED_PIN3, OUTPUT); } void fadeIn(uint8_t ledNo) { for(uint8_t i = 0; i  Pokaż rozwiązanie   Czy jesteś w stanie napisać również funkcję fadeOut(), zmniejszającą jasność od największej do zera?\nvoid fadeOut(uint8_t ledNo) { for(uint8_t i = 0; i  Pokaż rozwiązanie   Pseudo asynchroniczna kontrola LED W poprzednich przykładach, Mogliśmy jednocześnie zmieniać jasność tylko jednej diody. Nie jest to rozwiązanie stosowane w praktyce, ponieważ nie chcemy aby nasz “potężny” procesor marnował tyle czasu. Dla przykładu, chcąc obrócić dwa koła samochodu o 360 stopni, musimy zrobić to jednocześnie. W przeciwnym razie, znajdziemy się w zupełnie innym miejscu (zakładając, że w ogóle ruszymy).\nW tym celu skorzystamy z funkcji milis(). Zwraca ona liczbę milisekund które upłynęły od startu naszego procesora. Czas ten, według dokumentacji, wyzeruje się po około 50 dniach. Dlatego, do zapamiętania czasu, potrzebujemy zmiennej o dużym rozmiarze: long.\nZmienną o nazwie lastUpdate będziemy przechowywać poza blokami setup() oraz loop. Oznacza to, że będzie ona zmienną gobalną, dostępną w każdym miejscu kodu. Podobnie zapiszemy zmienną currentBrightness.\n#include \"Arduino.h\"#define LED_PIN1 D6 #define LED_PIN2 D7 #define LED_PIN3 D8  long lastUpdate = 0; uint8_t currentBrightness = 0; void setup() { pinMode(LED_PIN1, OUTPUT); pinMode(LED_PIN2, OUTPUT); pinMode(LED_PIN3, OUTPUT); } void loop() { if( (lastUpdate + 50)  millis() ) { analogWrite(LED_PIN1, currentBrightness); analogWrite(LED_PIN2, currentBrightness); analogWrite(LED_PIN3, currentBrightness); currentBrightness++; lastUpdate = millis(); } } W powyższym kodzie, znajduje się instrukcja warunkowa if. Sprawdza ona, czy wartość logiczna w nawiasach jest prawdą (w tym przypadku, czy ostatnia aktualizacja, była ponad 50ms temu). Jeśli tak, to aktualizuje wartość każdej LED oraz zwiększa ją o jeden.\nKod ten, zawiera jednak drobną pułapkę. currentBrightness będąc typu uint8_t, przyjmuje maksymalnie wartość 2 do potęgi 8 - 1 (255). Gdy spróbujemy ją zwiększyć, znów przyjmie wartość 0 gasząc diodę. Więcej na ten temat, przeczytasz tutaj.\nObsługa wejścia Wielokrotnie, potrzebujemy dostarczyć do mikrokontrolera jakieś informacje. Taką informacją może być na przykład naciśnięcie przycisku, wpisanie kodu czy ustawienie głośności.\nPort szeregowy Na początek, skonfigurujmy jednak port szeregowy który pozwoli nam na wysyłanie “logów” do komputera. Obiekt Serial zawiera zbiór funkcji pozwalających na komunikację przy użyciu portu szeregowego. Funkcja Serial.begin(115200) inicjalizuje obiekt. Parametr 115200 to prędkość, z jaką przesyłane są dane.\nW funkcji loop wywołujemy funkcję println(), a jako parametr podajemy tekst, który chcemy wysłać. Warto zauważyć, że w C++ obiekty mogą zawierać funkcje.\n#include \"Arduino.h\" void setup() { Serial.begin(115200); } void loop() { Serial.println(\"Hello World\"); delay(500); } Uruchom w swoim ArduinoIDE Monitor portu szeregowego w prawym górnym rogu, a następnie ustaw odpowiednią prędkość transmisji (baudrate). Pokaż rozwiązanie  \nObsługa przycisku - odczyt GPIO Zbuduj na swojej płytce konfigurację z poniższego obrazka, podłączając przycisk pomiędzy piny GND a D1 Rozbudujmy powyższy kod o czytanie informacji o stanie przycisku. Znamy już instrukcje warunkowe. Znamy też funkcję pinMode. Pojawia się tu jednak nowy argument - INPUT_PULLUP. Oznacza on, że mikrokontroler dołączy wewnętrzny rezystor między nasz pin, a zasilanie. Spowoduje to, że czytając wartość pinu, zobaczymy stan wysoki. Chyba, że naciśniemy przycisk, który zewrze pin do masy.\nWgraj poniższy kod na swoją płytkę. Naciskając przycisk, obserwuj port szeregowy.\n#include \"Arduino.h\"#define BUTTON_PIN D1 void setup() { pinMode(BUTTON_PIN, INPUT_PULLUP); Serial.begin(115200); } void loop() { if(digitalRead(BUTTON_PIN)) Serial.println(\"UP\"); else Serial.println(\"DOWN\"); delay(500); } Czy jesteś w stanie powiedzieć, jaką wartość zwraca digitalRead gdy przycisk nie jest wciśnięty?\nObsługa przycisku - przerwanie Wcześniej mówiliśmy o tym, że kod powinien być nieblokujący. Każda linijka kodu wykonywanego w pętli, to conajmniej jedna instrukcja. Czy gdybyśmy musieli w ten sposób obsłużyć 64 przyciski, każdemu przypisując złożone zadania, to czy nasz kod byłby wystarczająco szybki?\nNa szczęście, mikrokontrolery obsługują tak zwane przerwania. Są to funkcje wywoływane w odpowiedzi na jakieś zdarzenie.\nFunkcja\nattachInterrupt(digitalPinToInterrupt(BUTTON_PIN), handleBtnPress, FALLING); dołącza do pinu przycisku funkcję handleBtnPress. Jest to funkcja inicjalizująca, wywoływana na początku kodu. Wyzwoli ona funkcję handleBtnPress w przypadku naciśnięcia przycisku. FALLING, oznacza zbocze opadające. A więc gdy stan pinu zmienia się z wysokiego, na niski (napięcie “spada”).\nCzy jesteś w stanie napisać funkcję handleBtnPress która wypisze na port szeregowy napis “Hello IRQ”? Pamiętaj, aby odpowiednio umiejscowić attachInterrupt()\nUWAGA! Ze względu na platformę z której korzystamy, przed zwracanym typem funkcji musisz dodać ICACHE_RAM_ATTR. W przeciwnym razie… Sprawdź :) Dyrektywa ta, mówi kompilatorowi w jakiej pamięci umieścić daną instrukcję.\n#include \"Arduino.h\" #define BUTTON_PIN D1 ICACHE_RAM_ATTR void handleBtnPress() { Serial.println(\"button pressed\"); } void setup() { pinMode(BUTTON_PIN, INPUT_PULLUP); attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), handleBtnPress, FALLING); Serial.begin(115200); } void loop() { }  Pokaż rozwiązanie   Zadanie - kontrola głośności dwoma przyciskami (opcjonalne) Przy pomocy dwóch przycisków stwórz sterowanie głośnością (wysyłanie aktualnej wartości na Monitor Portu Szeregowego)\n Skonfiguruj dwa piny jako przerwania  Stwórz dwie funkcję volumeUp() i volumeDown() podłączone do przerwań   Przechowuj wartość głośności jako zmienną o maksymalnej wartości 10 Zapewnij, by wartość głośności nie mogła być mniejsza niż 0 i większa niż 10 (tip: if, else) W loop(), co pół sekundy “printuj” wartość głośności  Możesz zaprezentować wartość na kilku diodach LED. (tak, jak wskaźnik poziomu wody)    Odczyt pinu analogowego - potencjometr Na początku rozdziału ustawialiśmy przy użyciu PWM, jak mocno świeci dioda. Podobnie, używając mikroprocesora, możemy odczytać wartość napięcia. Mikrokontrolery, posiadają wbudowane przetworniki ADC (Analog to Digital Converter). Więcej na ten temat, możesz poczytać tutaj.\nPodłącz potencjometr zgodnie z poniższym schematem. Wykorzystaj piny\n 3V3 GND D1   Następnie, wgraj na płytkę poniższy kod\n#include \"Arduino.h\"#define POTENTIOMETER_PIN D1  void setup() { pinMode(POTENTIOMETER_PIN, INPUT); Serial.begin(115200); } void loop() { Serial.println(analogRead(POTENTIOMETER_PIN)); delay(100); } Obracając potencjometr, obserwuj port szeregowy. Czy wartości zmieniają się? Czy jesteś w stanie wskazać parametr odpowiedzialny za to jak duże wartości i ich zmiany obserwujesz?\nPrzetworniki, posiadają rozdzielczość. To ona definiuje dokładne są nasze pomiary. Nasz przetwornik, przetwornikiem 10-cio bitowym.  Pokaż rozwiązanie   ","wordCount":"1463","inLanguage":"en","datePublished":"2023-02-13T16:35:29+01:00","dateModified":"2023-02-13T16:35:29+01:00","author":{"@type":"Person","name":"Radosław Sajdak"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://radoslawsajdak.github.io/post/gpio/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://radoslawsajdak.github.io/favicon.ico"}}}</script>
</head>
<body class=dark id=top>
<script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://radoslawsajdak.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://radoslawsajdak.github.io/post/>Posts</a></div>
<h1 class=post-title>
GPIO
</h1>
<div class=post-meta><span title="2023-02-13 16:35:29 +0100 CET">February 13, 2023</span>&nbsp;·&nbsp;1463 words&nbsp;·&nbsp;Radosław Sajdak
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><nav id=TableOfContents>
<ul>
<li><a href=#obsługa-wielu-wyjść-cyfrowych>Obsługa wielu wyjść cyfrowych</a>
<ul>
<li><a href=#funkcja-mrugająca-diodą>Funkcja, mrugająca diodą</a></li>
<li><a href=#sterowanie-jasnością-led---pwm-pulse-width-modulation>Sterowanie jasnością LED - PWM (Pulse Width Modulation)</a></li>
<li><a href=#narastająca-jasność---pętle>Narastająca jasność - pętle</a></li>
<li><a href=#pseudo-asynchroniczna-kontrola-led>Pseudo asynchroniczna kontrola LED</a></li>
</ul>
</li>
<li><a href=#obsługa-wejścia>Obsługa wejścia</a>
<ul>
<li><a href=#port-szeregowy>Port szeregowy</a></li>
<li><a href=#obsługa-przycisku---odczyt-gpio>Obsługa przycisku - odczyt GPIO</a></li>
<li><a href=#obsługa-przycisku---przerwanie>Obsługa przycisku - przerwanie</a></li>
<li><a href=#odczyt-pinu-analogowego---potencjometr>Odczyt pinu analogowego - potencjometr</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</details>
</div>
<div class=post-content><h1 id=gpio-general-purpose-input-output>GPIO (General-Purpose Input Output)<a hidden class=anchor aria-hidden=true href=#gpio-general-purpose-input-output>#</a></h1>
<h2 id=obsługa-wielu-wyjść-cyfrowych>Obsługa wielu wyjść cyfrowych<a hidden class=anchor aria-hidden=true href=#obsługa-wielu-wyjść-cyfrowych>#</a></h2>
<p>Po ukończeniu wprowadzenia, wiesz już jak zamrugać diodą. Każda dioda, ma katodę (-) oraz anodę (+).
Anoda, posiada krótszą nóżkę i to do niej należy podłączyć zasilanie. Można skojarzyć to prez znaną
nazwę AK47 (prąd płynie A -> K, a 4 jest mniejsze niż 7 :)). Dodatkowo, aby ograniczyć prąd płynący przez
diodę, należy szeregowo włączyć do niej rezystor. Podobnie jak na poniższym obrazku, podłącz trzy diody
do pinów <strong>D5, D6, D7</strong>.</p>
<link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=three_leds type=checkbox>
<img src=images/three_leds.png>
<label for=three_leds class=spoiler-button>Pokaż rozwiązanie
</div>
</figure>
<p>Wiedząc, że</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>digitalWrite</span><span class=p>(</span><span class=n>PIN_NUMBER</span><span class=p>,</span> <span class=n>LOGIC_LEVEL</span><span class=p>);</span>
</code></pre></div><p>oraz</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>pinMode</span><span class=p>(</span><span class=n>PIN_NUMBER</span><span class=p>,</span> <span class=n>LOGIC_LEVEL</span><span class=p>);</span>
</code></pre></div><p>spróbuj zamrugać trzema diodami po kolei.</p>
<link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=code0 type=checkbox>
<pre><code class=language-c>
#include "Arduino.h"
#define LED_PIN1 D6
#define LED_PIN2 D7
#define LED_PIN3 D8
#define LED_BLINK_PERIOD 1000

void setup()
{
    pinMode(LED_PIN1, OUTPUT);
    pinMode(LED_PIN2, OUTPUT);
    pinMode(LED_PIN3, OUTPUT);
}

void loop()
{
    digitalWrite(LED_PIN1, HIGH);
    delay(LED_BLINK_PERIOD);
    digitalWrite(LED_PIN1, LOW);
    delay(LED_BLINK_PERIOD);

    digitalWrite(LED_PIN2, HIGH);
    delay(LED_BLINK_PERIOD);
    digitalWrite(LED_PIN2, LOW);
    delay(LED_BLINK_PERIOD);

    digitalWrite(LED_PIN3, HIGH);
    delay(LED_BLINK_PERIOD);
    digitalWrite(LED_PIN3, LOW);
    delay(LED_BLINK_PERIOD);
}
</pre></code>
<label for=code0 class=spoiler-button>Pokaż rozwiązanie
</div>
</figure>
<h3 id=funkcja-mrugająca-diodą>Funkcja, mrugająca diodą<a hidden class=anchor aria-hidden=true href=#funkcja-mrugająca-diodą>#</a></h3>
<p>Aby uniknąć powielania kodu, co zrobiliśmy powyżej, tworzymy funkcje. W językach o typie statycznym (C, C++)
mają zazwyczaj format <strong>[typ zwracany] nazwa_funkcji(typ argumentu1, typ argumentu2){ [Kod tutaj] }</strong>.</p>
<p>Typy, różnią się od siebie rozmiarem.
Wyjątkiem, jest typ <strong>void</strong> który informuje nas, że funkcja nie zwraca niczego.</p>
<p>Spróbuj napisać funkcję mrugającą diodą:</p>
<ul>
<li>o nazwie <strong>blinkLED</strong></li>
<li>zwracającą <strong>void</strong></li>
<li>przyjmującą jeden argument typu <strong>uint8_t</strong>.</li>
</ul>
<p>Na ten moment przyjmijmy, że funkcje znajdują się powyżej</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>setup</span><span class=p>()</span>
<span class=p>{</span>

<span class=p>}</span>
</code></pre></div><p><link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=code1 type=checkbox>
<pre><code class=language-c>
void blinkLED(uint8_t ledNo)
{
    digitalWrite(ledNo, HIGH);
    delay(LED_BLINK_PERIOD);
    digitalWrite(ledNo, LOW);
    delay(LED_BLINK_PERIOD);
}
</pre></code>
<label for=code1 class=spoiler-button>Pokaż rozwiązanie
</div>
</figure>
Używając napisanej przez Ciebie funkcji, popraw nasz wcześniejszy przykład.</p>
<link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=code2 type=checkbox>
<pre><code class=language-c>
void loop()
{
    blinkLED(LED_PIN1);
    blinkLED(LED_PIN2);
    blinkLED(LED_PIN3);
}
</pre></code>
<label for=code2 class=spoiler-button>Pokaż rozwiązanie
</div>
</figure>
<h3 id=sterowanie-jasnością-led---pwm-pulse-width-modulation>Sterowanie jasnością LED - PWM (Pulse Width Modulation)<a hidden class=anchor aria-hidden=true href=#sterowanie-jasnością-led---pwm-pulse-width-modulation>#</a></h3>
<p>Każdy z naszych pinów, może pracować w różnych trybach. Jednym z nich jest PWM, czyli modulacja wypełnieniem sygnału.
Upraszczając, możemy sterować tym jaki procent czasu pin jest w stanie wysokim, a jaki w niskim. Służy do tego funkcja</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>analogWrite</span><span class=p>(</span><span class=n>PIN_NUMBER</span><span class=p>,</span> <span class=n>VALUE</span><span class=p>(</span><span class=mi>0</span><span class=o>-</span><span class=mi>255</span><span class=p>));</span>
</code></pre></div><p>Dodatkowe informacje znajdziesz w:</p>
<ul>
<li>Dokumentacji biblioteki arduino <a href=https://www.arduino.cc/reference/en/language/functions/analog-io/analogwrite/>link</a></li>
<li>Krótkim tutorialu o PWM <a href=https://www.arduino.cc/pl/Tutorial/Foundations/PWM>link</a></li>
</ul>
<p>Spróbuj uruchomić na swojej płytce poniższy kod. Czy LED zmienia jasność krokowo?</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>loop</span><span class=p>(){</span>
    <span class=n>analogWrite</span><span class=p>(</span><span class=n>LED_PIN1</span><span class=p>,</span> <span class=mi>50</span><span class=p>);</span>
    <span class=n>delay</span><span class=p>(</span><span class=n>LED_BLINK_PERIOD</span><span class=p>);</span>
    <span class=n>analogWrite</span><span class=p>(</span><span class=n>LED_PIN1</span><span class=p>,</span> <span class=mi>150</span><span class=p>);</span>
    <span class=n>delay</span><span class=p>(</span><span class=n>LED_BLINK_PERIOD</span><span class=p>);</span>
    <span class=n>analogWrite</span><span class=p>(</span><span class=n>LED_PIN1</span><span class=p>,</span> <span class=mi>250</span><span class=p>);</span>
    <span class=n>delay</span><span class=p>(</span><span class=n>LED_BLINK_PERIOD</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><h3 id=narastająca-jasność---pętle>Narastająca jasność - pętle<a hidden class=anchor aria-hidden=true href=#narastająca-jasność---pętle>#</a></h3>
<p>Chcąc aby nasz LED rozjaśniał się płynnie, musielibyśmy 255 razy wywołać funkcję <code>analogWrite()</code>. Nie
byłoby to jednak ani czytelne, ani wydajne. Służą do tego <strong>pętle</strong>. Pozwalają one na wywołanie jakiegoś
fragmentu kodu, ściśle określoną ilość razy. W C, używamy trzech pętli:</p>
<ul>
<li><code>do{ [kod] }while(warunek)</code></li>
<li><code>while(warunek){ [kod] }</code></li>
<li><code>for(iterator; warunek; instrukcja){ [kod] }</code></li>
</ul>
<p>Każda z nich, działa w trochę różny sposób.</p>
<ul>
<li><code>do{ [kod] }while(warunek)</code>, sprawdza warunek <strong>po</strong> wyjściu z bloku kodu</li>
<li><code>while(warunek){ [kod] }</code>, sprawdza warunek <strong>przed</strong> wejściem do bloku kodu</li>
<li><code>for(iterator; warunek; instrukcja){ [kod] }</code> może stworzyć element (np. iterator), sprawdza warunek <strong>przed</strong> wejściem,
ale również wykonuje jakąś instrukcje (np. dodawanie) <strong>po</strong> wyjściu z bloku.</li>
</ul>
<p>Używany przez nas</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>loop</span><span class=p>()</span>
<span class=p>{</span>

<span class=p>}</span>
</code></pre></div><p>To nic innego jak</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=p>{</span>

<span class=p>}</span>
</code></pre></div><p>W naszych przykładach, będziemy używać głównie pętli <code>for</code>. Jest ona najwygodniejsza w użyciu, ponieważ pozwala wykonać
wszystkie niezbędne operacje związane z pętlami w przejrzysty sposób.<br>
Więcej o pętli <code>for</code>, możesz przeczytać <a href=https://www.programiz.com/c-programming/c-for-loop>tutaj</a></p>
<p>Spróbuj napisać funkcję <code>fadeIn()</code>, która będzie rozjaśniać diodę led w sposób płynny. Użyj do tego pętli</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>for</span><span class=p>(</span><span class=kt>uint8_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>255</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
<span class=p>{</span>

<span class=p>}</span>
</code></pre></div><p><strong>UWAGA!</strong> Ze względu na charakterystykę diody, wyższe wartości <code>i</code> mogą nie wpływać wyraźnie na jasność diody, jednak bez problemu zaobserwujesz rozjaśnianie.</p>
<link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=code3 type=checkbox>
<pre><code class=language-c>
#include "Arduino.h"
#define LED_PIN1 D6
#define LED_PIN2 D7
#define LED_PIN3 D8
#define LED_BLINK_PERIOD 1000

void setup()
{
    pinMode(LED_PIN1, OUTPUT);
    pinMode(LED_PIN2, OUTPUT);
    pinMode(LED_PIN3, OUTPUT);
}

void fadeIn(uint8_t ledNo)
{
    for(uint8_t i = 0; i < 255; i++){
        analogWrite(ledNo, i);
        delay(10);
    }
}

void loop()
{
    fadeIn(LED_PIN1);
    fadeIn(LED_PIN2);
    fadeIn(LED_PIN3);
}
</pre></code>
<label for=code3 class=spoiler-button>Pokaż rozwiązanie
</div>
</figure>
<p>Czy jesteś w stanie napisać również funkcję <code>fadeOut()</code>, zmniejszającą jasność od największej do zera?</p>
<link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=code4 type=checkbox>
<pre><code class=language-c>
void fadeOut(uint8_t ledNo)
{
    for(uint8_t i = 0; i < 255; i++){
        analogWrite(ledNo, 255 - i);
        delay(10);
    }
}
</pre></code>
<label for=code4 class=spoiler-button>Pokaż rozwiązanie
</div>
</figure>
<h3 id=pseudo-asynchroniczna-kontrola-led>Pseudo asynchroniczna kontrola LED<a hidden class=anchor aria-hidden=true href=#pseudo-asynchroniczna-kontrola-led>#</a></h3>
<p>W poprzednich przykładach, Mogliśmy jednocześnie zmieniać jasność tylko jednej diody. Nie jest to rozwiązanie stosowane
w praktyce, ponieważ nie chcemy aby nasz &ldquo;potężny&rdquo; procesor marnował tyle czasu. Dla przykładu, chcąc obrócić dwa koła samochodu o 360 stopni, musimy zrobić to jednocześnie. W przeciwnym razie, znajdziemy się w zupełnie innym miejscu (zakładając, że w ogóle ruszymy).</p>
<p>W tym celu skorzystamy z funkcji <code>milis()</code>. Zwraca ona liczbę milisekund które upłynęły od startu naszego
procesora. Czas ten, według dokumentacji, wyzeruje się po około 50 dniach. Dlatego, do zapamiętania czasu,
potrzebujemy zmiennej o dużym rozmiarze: <code>long</code>.</p>
<p>Zmienną o nazwie <code>lastUpdate</code> będziemy przechowywać poza blokami <code>setup()</code> oraz <code>loop</code>. Oznacza to, że
będzie ona zmienną <strong>gobalną</strong>, dostępną w każdym miejscu kodu. Podobnie zapiszemy zmienną <code>currentBrightness</code>.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&#34;Arduino.h&#34;</span><span class=cp>
</span><span class=cp>#define LED_PIN1 D6
</span><span class=cp>#define LED_PIN2 D7
</span><span class=cp>#define LED_PIN3 D8
</span><span class=cp></span>
<span class=kt>long</span> <span class=n>lastUpdate</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=kt>uint8_t</span> <span class=n>currentBrightness</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>setup</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>pinMode</span><span class=p>(</span><span class=n>LED_PIN1</span><span class=p>,</span> <span class=n>OUTPUT</span><span class=p>);</span>
    <span class=n>pinMode</span><span class=p>(</span><span class=n>LED_PIN2</span><span class=p>,</span> <span class=n>OUTPUT</span><span class=p>);</span>
    <span class=n>pinMode</span><span class=p>(</span><span class=n>LED_PIN3</span><span class=p>,</span> <span class=n>OUTPUT</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>loop</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>if</span><span class=p>(</span> <span class=p>(</span><span class=n>lastUpdate</span> <span class=o>+</span> <span class=mi>50</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>millis</span><span class=p>()</span> <span class=p>)</span>
    <span class=p>{</span>
        <span class=n>analogWrite</span><span class=p>(</span><span class=n>LED_PIN1</span><span class=p>,</span> <span class=n>currentBrightness</span><span class=p>);</span>
        <span class=n>analogWrite</span><span class=p>(</span><span class=n>LED_PIN2</span><span class=p>,</span> <span class=n>currentBrightness</span><span class=p>);</span>
        <span class=n>analogWrite</span><span class=p>(</span><span class=n>LED_PIN3</span><span class=p>,</span> <span class=n>currentBrightness</span><span class=p>);</span>
        <span class=n>currentBrightness</span><span class=o>++</span><span class=p>;</span>
        <span class=n>lastUpdate</span> <span class=o>=</span> <span class=n>millis</span><span class=p>();</span>
    <span class=p>}</span>   
    
<span class=p>}</span>

</code></pre></div><p>W powyższym kodzie, znajduje się instrukcja warunkowa <code>if</code>. Sprawdza ona, czy wartość logiczna w nawiasach jest prawdą
(w tym przypadku, czy ostatnia aktualizacja, była ponad 50ms temu). Jeśli tak, to aktualizuje wartość każdej LED oraz zwiększa ją o jeden.</p>
<p>Kod ten, zawiera jednak drobną pułapkę. <code>currentBrightness</code> będąc typu <code>uint8_t</code>, przyjmuje maksymalnie wartość 2 do potęgi 8 - 1 (255). Gdy spróbujemy ją zwiększyć, znów przyjmie wartość 0 gasząc diodę. Więcej na ten temat, przeczytasz <a href=https://www.bbc.co.uk/bitesize/guides/z26rcdm/revision/5>tutaj</a>.</p>
<h2 id=obsługa-wejścia>Obsługa wejścia<a hidden class=anchor aria-hidden=true href=#obsługa-wejścia>#</a></h2>
<p>Wielokrotnie, potrzebujemy dostarczyć do mikrokontrolera jakieś informacje. Taką informacją może być na przykład
naciśnięcie przycisku, wpisanie kodu czy ustawienie głośności.</p>
<h3 id=port-szeregowy>Port szeregowy<a hidden class=anchor aria-hidden=true href=#port-szeregowy>#</a></h3>
<p>Na początek, skonfigurujmy jednak port szeregowy który pozwoli nam na wysyłanie &ldquo;logów&rdquo; do komputera.
Obiekt <code>Serial</code> zawiera zbiór funkcji pozwalających na komunikację przy użyciu portu szeregowego. Funkcja <code>Serial.begin(115200)</code>
inicjalizuje obiekt. Parametr <code>115200</code> to prędkość, z jaką przesyłane są dane.</p>
<p>W funkcji loop wywołujemy funkcję <code>println()</code>, a jako parametr podajemy tekst, który chcemy wysłać. Warto zauważyć, że w C++ obiekty mogą zawierać funkcje.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=cp>#include</span> <span class=cpf>&#34;Arduino.h&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>void</span> <span class=nf>setup</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>Serial</span><span class=p>.</span><span class=n>begin</span><span class=p>(</span><span class=mi>115200</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>loop</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>Serial</span><span class=p>.</span><span class=n>println</span><span class=p>(</span><span class=s>&#34;Hello World&#34;</span><span class=p>);</span>
    <span class=n>delay</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>Uruchom w swoim ArduinoIDE Monitor portu szeregowego w prawym górnym rogu, a następnie ustaw odpowiednią prędkość transmisji (baudrate).
<link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=setup_monitor type=checkbox>
<img src=images/setup_monitor.png>
<label for=setup_monitor class=spoiler-button>Pokaż rozwiązanie
</div>
</figure></p>
<h3 id=obsługa-przycisku---odczyt-gpio>Obsługa przycisku - odczyt GPIO<a hidden class=anchor aria-hidden=true href=#obsługa-przycisku---odczyt-gpio>#</a></h3>
<p>Zbuduj na swojej płytce konfigurację z poniższego obrazka, podłączając przycisk pomiędzy piny <code>GND</code> a <code>D1</code>
<img loading=lazy src=images/button-connect.png#center alt=button_connect>
</p>
<p>Rozbudujmy powyższy kod o czytanie informacji o stanie przycisku. Znamy już instrukcje warunkowe. Znamy też
funkcję <code>pinMode</code>. Pojawia się tu jednak nowy argument - <code>INPUT_PULLUP</code>. Oznacza on, że mikrokontroler dołączy
wewnętrzny rezystor między nasz pin, a zasilanie. Spowoduje to, że czytając wartość pinu, zobaczymy stan wysoki.
Chyba, że naciśniemy przycisk, który zewrze pin do masy.</p>
<p>Wgraj poniższy kod na swoją płytkę. Naciskając przycisk, obserwuj port szeregowy.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=cp>#include</span> <span class=cpf>&#34;Arduino.h&#34;</span><span class=cp>
</span><span class=cp>#define BUTTON_PIN D1
</span><span class=cp></span><span class=kt>void</span> <span class=nf>setup</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>pinMode</span><span class=p>(</span><span class=n>BUTTON_PIN</span><span class=p>,</span> <span class=n>INPUT_PULLUP</span><span class=p>);</span>
    <span class=n>Serial</span><span class=p>.</span><span class=n>begin</span><span class=p>(</span><span class=mi>115200</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>loop</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=n>digitalRead</span><span class=p>(</span><span class=n>BUTTON_PIN</span><span class=p>))</span>
        <span class=n>Serial</span><span class=p>.</span><span class=n>println</span><span class=p>(</span><span class=s>&#34;UP&#34;</span><span class=p>);</span>
    <span class=k>else</span> 
        <span class=n>Serial</span><span class=p>.</span><span class=n>println</span><span class=p>(</span><span class=s>&#34;DOWN&#34;</span><span class=p>);</span>
    <span class=n>delay</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>
<span class=p>}</span>

</code></pre></div><p>Czy jesteś w stanie powiedzieć, jaką wartość zwraca <code>digitalRead</code> gdy przycisk nie jest wciśnięty?</p>
<h3 id=obsługa-przycisku---przerwanie>Obsługa przycisku - przerwanie<a hidden class=anchor aria-hidden=true href=#obsługa-przycisku---przerwanie>#</a></h3>
<p>Wcześniej mówiliśmy o tym, że kod powinien być nieblokujący. Każda linijka kodu wykonywanego w pętli,
to conajmniej jedna instrukcja. Czy gdybyśmy musieli w ten sposób obsłużyć 64 przyciski, każdemu przypisując
złożone zadania, to czy nasz kod byłby wystarczająco szybki?</p>
<p>Na szczęście, mikrokontrolery obsługują tak zwane przerwania. Są to funkcje wywoływane w odpowiedzi na jakieś zdarzenie.<br>
Funkcja</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=n>attachInterrupt</span><span class=p>(</span><span class=n>digitalPinToInterrupt</span><span class=p>(</span><span class=n>BUTTON_PIN</span><span class=p>),</span> <span class=n>handleBtnPress</span><span class=p>,</span> <span class=n>FALLING</span><span class=p>);</span>
</code></pre></div><p>dołącza do pinu przycisku funkcję <code>handleBtnPress</code>. Jest to funkcja inicjalizująca, wywoływana na początku kodu.
Wyzwoli ona funkcję <code>handleBtnPress</code> w przypadku naciśnięcia przycisku.
<code>FALLING</code>, oznacza zbocze opadające. A więc gdy stan pinu zmienia się z wysokiego, na niski (napięcie &ldquo;spada&rdquo;).</p>
<p>Czy jesteś w stanie napisać funkcję <code>handleBtnPress</code> która wypisze na port szeregowy napis &ldquo;Hello IRQ&rdquo;? Pamiętaj, aby
odpowiednio umiejscowić <code>attachInterrupt()</code></p>
<p><strong>UWAGA!</strong> Ze względu na platformę z której korzystamy, przed zwracanym typem funkcji <strong>musisz</strong> dodać <code>ICACHE_RAM_ATTR</code>. W przeciwnym razie&mldr; Sprawdź :) Dyrektywa ta, mówi kompilatorowi w jakiej pamięci umieścić daną instrukcję.</p>
<link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=code5 type=checkbox>
<pre><code class=language-c>
#include "Arduino.h"
#define BUTTON_PIN D1

ICACHE_RAM_ATTR void handleBtnPress()
{
    Serial.println("button pressed");
}

void setup()
{
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), handleBtnPress, FALLING);
    Serial.begin(115200);
}

void loop()
{

}
</pre></code>
<label for=code5 class=spoiler-button>Pokaż rozwiązanie
</div>
</figure>
<h4 id=zadanie---kontrola-głośności-dwoma-przyciskami-opcjonalne>Zadanie - kontrola głośności dwoma przyciskami (opcjonalne)<a hidden class=anchor aria-hidden=true href=#zadanie---kontrola-głośności-dwoma-przyciskami-opcjonalne>#</a></h4>
<p>Przy pomocy dwóch przycisków stwórz sterowanie głośnością (wysyłanie aktualnej wartości na Monitor Portu Szeregowego)</p>
<ul>
<li>Skonfiguruj dwa piny jako przerwania
<ul>
<li>Stwórz dwie funkcję <code>volumeUp()</code> i <code>volumeDown()</code> podłączone do przerwań</li>
</ul>
</li>
<li>Przechowuj wartość głośności jako zmienną o maksymalnej wartości 10</li>
<li>Zapewnij, by wartość głośności nie mogła być mniejsza niż 0 i większa niż 10 (tip: if, else)</li>
<li>W <code>loop()</code>, co pół sekundy &ldquo;printuj&rdquo; wartość głośności
<ul>
<li>Możesz zaprezentować wartość na kilku diodach LED. (tak, jak wskaźnik poziomu wody)</li>
</ul>
</li>
</ul>
<h3 id=odczyt-pinu-analogowego---potencjometr>Odczyt pinu analogowego - potencjometr<a hidden class=anchor aria-hidden=true href=#odczyt-pinu-analogowego---potencjometr>#</a></h3>
<p>Na początku rozdziału ustawialiśmy przy użyciu PWM, jak mocno świeci dioda. Podobnie, używając mikroprocesora,
możemy odczytać wartość napięcia. Mikrokontrolery, posiadają wbudowane przetworniki ADC (Analog to Digital Converter). Więcej na ten temat, możesz poczytać <a href=https://forbot.pl/blog/leksykon/adc-a-d>tutaj</a>.</p>
<p>Podłącz potencjometr zgodnie z poniższym schematem. Wykorzystaj piny</p>
<ul>
<li>3V3</li>
<li>GND</li>
<li>D1
<img loading=lazy src=images/potentiometer-connect.png alt=potentiometer_connect>
</li>
</ul>
<p>Następnie, wgraj na płytkę poniższy kod</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=cp>#include</span> <span class=cpf>&#34;Arduino.h&#34;</span><span class=cp>
</span><span class=cp>#define POTENTIOMETER_PIN D1
</span><span class=cp></span>
<span class=kt>void</span> <span class=nf>setup</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>pinMode</span><span class=p>(</span><span class=n>POTENTIOMETER_PIN</span><span class=p>,</span> <span class=n>INPUT</span><span class=p>);</span>
    <span class=n>Serial</span><span class=p>.</span><span class=n>begin</span><span class=p>(</span><span class=mi>115200</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>loop</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>Serial</span><span class=p>.</span><span class=n>println</span><span class=p>(</span><span class=n>analogRead</span><span class=p>(</span><span class=n>POTENTIOMETER_PIN</span><span class=p>));</span>
    <span class=n>delay</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>Obracając potencjometr, obserwuj port szeregowy. Czy wartości zmieniają się? Czy jesteś w stanie
wskazać parametr odpowiedzialny za to jak duże wartości i ich zmiany obserwujesz?</p>
<link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=hint_adc type=checkbox>
<pre><code class=html>
Przetworniki, posiadają rozdzielczość. To ona definiuje dokładne są nasze pomiary.
Nasz przetwornik, przetwornikiem 10-cio bitowym.
</pre></code>
<label for=hint_adc class=spoiler-button>Pokaż rozwiązanie
</div>
</figure>
</div>
<footer class=post-footer>
<ul class=post-tags>
</ul>
<nav class=paginav>
<a class=prev href=https://radoslawsajdak.github.io/post/getting_started/>
<span class=title>« Prev</span>
<br>
<span>Getting started</span>
</a>
<a class=next href=https://radoslawsajdak.github.io/post/uart/>
<span class=title>Next »</span>
<br>
<span>UART (Universal Asynchronous Receiver-Transmitter)</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2023 <a href=https://radoslawsajdak.github.io/></a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>