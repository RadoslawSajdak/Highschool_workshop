<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>UART (Universal Asynchronous Receiver-Transmitter) | </title>
<meta name=keywords content>
<meta name=description content="&ldquo;UART (Universal Asynchronous Receiver-Transmitter)&rdquo; UART jest jednym z najczęściej stosowanych protokołów komunikacyjnych. Stosuje się go m.in.:
 W komunikacji między procesorami Do wyprowadzania tzw. &ldquo;Debugu&rdquo; Do komunikacji z modułami (Bluetooth, GPS, LTE itp.)  Poznaliśmy wcześniej monitor portu szeregowego. Jest to nic innego, jak właśnie UART. W ten sposób, wysyłając bajt po bajcie, czytaliśmy wiadomości wysyłane przez mikroprocesor.
Więcej na temat komunikacji UART, przeczytasz tutaj. Dla nas, najważniejszy jest sposób podłączenia &ldquo;na krzyż&rdquo;: UART - komunikacja z komputerem Czytanie wiadomości UART W rozdziale GPIO, przy użyciu biblioteki Serial, wysyłaliśmy wiadomości do naszego komputera.">
<meta name=author content="Radosław Sajdak">
<link rel=canonical href=www.hexu.pl/post/uart/>
<link crossorigin=anonymous href=/www.hexu.pl/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/www.hexu.pl/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=www.hexu.pl/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=www.hexu.pl/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=www.hexu.pl/favicon-32x32.png>
<link rel=apple-touch-icon href=www.hexu.pl/apple-touch-icon.png>
<link rel=mask-icon href=www.hexu.pl/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="UART (Universal Asynchronous Receiver-Transmitter)">
<meta property="og:description" content="&ldquo;UART (Universal Asynchronous Receiver-Transmitter)&rdquo; UART jest jednym z najczęściej stosowanych protokołów komunikacyjnych. Stosuje się go m.in.:
 W komunikacji między procesorami Do wyprowadzania tzw. &ldquo;Debugu&rdquo; Do komunikacji z modułami (Bluetooth, GPS, LTE itp.)  Poznaliśmy wcześniej monitor portu szeregowego. Jest to nic innego, jak właśnie UART. W ten sposób, wysyłając bajt po bajcie, czytaliśmy wiadomości wysyłane przez mikroprocesor.
Więcej na temat komunikacji UART, przeczytasz tutaj. Dla nas, najważniejszy jest sposób podłączenia &ldquo;na krzyż&rdquo;: UART - komunikacja z komputerem Czytanie wiadomości UART W rozdziale GPIO, przy użyciu biblioteki Serial, wysyłaliśmy wiadomości do naszego komputera.">
<meta property="og:type" content="article">
<meta property="og:url" content="www.hexu.pl/post/uart/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2023-02-13T16:41:13+01:00">
<meta property="article:modified_time" content="2023-02-13T16:41:13+01:00"><meta property="og:site_name" content="true">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="UART (Universal Asynchronous Receiver-Transmitter)">
<meta name=twitter:description content="&ldquo;UART (Universal Asynchronous Receiver-Transmitter)&rdquo; UART jest jednym z najczęściej stosowanych protokołów komunikacyjnych. Stosuje się go m.in.:
 W komunikacji między procesorami Do wyprowadzania tzw. &ldquo;Debugu&rdquo; Do komunikacji z modułami (Bluetooth, GPS, LTE itp.)  Poznaliśmy wcześniej monitor portu szeregowego. Jest to nic innego, jak właśnie UART. W ten sposób, wysyłając bajt po bajcie, czytaliśmy wiadomości wysyłane przez mikroprocesor.
Więcej na temat komunikacji UART, przeczytasz tutaj. Dla nas, najważniejszy jest sposób podłączenia &ldquo;na krzyż&rdquo;: UART - komunikacja z komputerem Czytanie wiadomości UART W rozdziale GPIO, przy użyciu biblioteki Serial, wysyłaliśmy wiadomości do naszego komputera.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"www.hexu.pl/post/"},{"@type":"ListItem","position":3,"name":"UART (Universal Asynchronous Receiver-Transmitter)","item":"www.hexu.pl/post/uart/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"UART (Universal Asynchronous Receiver-Transmitter)","name":"UART (Universal Asynchronous Receiver-Transmitter)","description":"\u0026ldquo;UART (Universal Asynchronous Receiver-Transmitter)\u0026rdquo; UART jest jednym z najczęściej stosowanych protokołów komunikacyjnych. Stosuje się go m.in.:\n W komunikacji między procesorami Do wyprowadzania tzw. \u0026ldquo;Debugu\u0026rdquo; Do komunikacji z modułami (Bluetooth, GPS, LTE itp.)  Poznaliśmy wcześniej monitor portu szeregowego. Jest to nic innego, jak właśnie UART. W ten sposób, wysyłając bajt po bajcie, czytaliśmy wiadomości wysyłane przez mikroprocesor.\nWięcej na temat komunikacji UART, przeczytasz tutaj. Dla nas, najważniejszy jest sposób podłączenia \u0026ldquo;na krzyż\u0026rdquo;: UART - komunikacja z komputerem Czytanie wiadomości UART W rozdziale GPIO, przy użyciu biblioteki Serial, wysyłaliśmy wiadomości do naszego komputera.","keywords":[],"articleBody":"“UART (Universal Asynchronous Receiver-Transmitter)” UART jest jednym z najczęściej stosowanych protokołów komunikacyjnych. Stosuje się go m.in.:\n W komunikacji między procesorami Do wyprowadzania tzw. “Debugu” Do komunikacji z modułami (Bluetooth, GPS, LTE itp.)  Poznaliśmy wcześniej monitor portu szeregowego. Jest to nic innego, jak właśnie UART. W ten sposób, wysyłając bajt po bajcie, czytaliśmy wiadomości wysyłane przez mikroprocesor.\nWięcej na temat komunikacji UART, przeczytasz tutaj. Dla nas, najważniejszy jest sposób podłączenia “na krzyż”: UART - komunikacja z komputerem Czytanie wiadomości UART W rozdziale GPIO, przy użyciu biblioteki Serial, wysyłaliśmy wiadomości do naszego komputera. Korzystając z tej samej biblioteki, możemy wysyłać wiadomości do mikrokonrolera. Poniższy kod, odbiera bajt po bajcie wiadomość z naszego portu szeregowego. Działa on w sposób nieblokujący, dzięki użyciu funkcji serialEvent(). Jej zawartość, można przenieść do funkcji loop() nie zmieniając działania kodu.\nUWAGA! Monitor portu szeregowego, domyślnie wysyła znak nowej linii po naciśnięciu klawisza “Enter”. Jest to znak \\n który przez systemy operacyjne interpretowany jest jako nowa linia. Z tego powodu, zobaczysz “dziwną” przerwę po ostatnim “received:”.\n#include \"Arduino.h\" void setup() { Serial.begin(115200); } void serialEvent(){ if (Serial.available()  0) { char character = Serial.read(); Serial.print(\"received: \"); Serial.println(character); } } void loop() { } Zazwyczaj, interesuje nas jednak reakcja kodu na całą komendę, a nie pojedynczy znak (choć nie zawsze). Biblioteka String.h, pozwala na operacje na ciągach znaków w bardzo intuicyjny sposób. Spróbuj:\n Utworzyć zmienną globalną typu String o nazwie inputString Dodawać do niej każdy odebrany bajt (tip. a += 1 to to samo co a = a + 1) Jeżeli bajt jest równy (==) znakowi nowej linii (\\n) wyprintuj zawartość inputString Przypisz do inputString wartość \"\" (wyzeruj)  #include \"Arduino.h\" String inputString; void setup() { Serial.begin(115200); } void serialEvent() { if (Serial.available()  0) { char character = Serial.read(); inputString += character; if(character == '\\n') { Serial.print(\"received: \"); Serial.println(inputString); inputString = \"\"; } } } void loop() { }  Pokaż rozwiązanie   Decyzje w oparciu o wiadomości UART - switch case W zależności od aplikacji, możemy chcieć wykonywać różne instrukcje w oparciu o wiadomości przyjęte na UART. Możemy zrobić to przy użyciu instrukcji switch([zmienna]) case [wariant]. Pozwala ona wykonywać instrukcje w zależności od argumentu. Działa ona podobnie do drabinki instrukcji if…\nswitch(zmienna) { case 'a': move_left(); break; case 's': move_down(); break; default: do_not_move(); break; } if (zmienna == 'a') { move_left(); } else if (zmienna == 's') { move_down(); } else { do_not_move(); } Obydwa powyższe fragmenty, realizują dokładnie tę samą logikę, jednak instrukcja switch jest szybsza i zdecydowanie bardziej czytelna. Szczególnie, gdy “gałęzi” jest wiele.\nBardzo ważne w instrukcji switch() jest zamknięcie przypadku (case) słowem break. W przeciwnym razie, mikrokontroler wywoła wszystkie instrukcje do napotkania pierwszego break.\nSpróbuj w naszym wcześniejszym kodzie zaimplementować “sterowanie” klawiszami wsad przy użyciu instrukcji switch.\n Czytaj jeden bajt z “Seriala” “Printuj” odpowiednio “UP”, “DOWN”, “LEFT”, “RIGHT” w zależności od wciśniętego przycisku. (Opcjonalne) obsłuż zarówno małe jak i wielkie litery (tip. czasem można celowo pominąć break)  #include \"Arduino.h\" void setup() { Serial.begin(115200); } void serialEvent() { if (Serial.available()  0) { char character = Serial.read(); switch(character) { case 'w': case 'W': Serial.println(\"UP!\"); break; case 's': case 'S': Serial.println(\"DOWN!\"); break; case 'a': case 'A': Serial.println(\"LEFT!\"); break; case 'd': case 'D': Serial.println(\"RIGHT!\"); break; } } } void loop() { }  Pokaż rozwiązanie   UART - transmisja bluetooth Jak wspomniałem na początku tego rozdziału, UART może służyć do obsługi modułów bezprzewodowych. Przykładem jednego z nich jest HC-05. Pozwala on na stworzenie bezprzewodowego monitora portu szeregowego, a następnie sterowania mikrokontrolerem z poziomu np. telefonu. Wgraj na swój mikrokontroler poniższy kod. Realizuje on funkcję “echo”, czyli zwraca na port szeregowy to, co zostanie do niego wysłane. Zwróć uwagę, że prędkość transmisji wynosi 9600!\n#include \"Arduino.h\" void setup() { Serial.begin(9600); } void serialEvent() { if (Serial.available()  0) { char character = Serial.read(); Serial.write(character); } } void loop() { } Następnie, podłącz moduł bluetooth zgodnie z poniższym schematem\nPokaż rozwiązanie   Uruchom na swoim telefonie bluetooth i sparuj urządzenie HC-05. UWAGA Niektóre telefony mogą nie wykrywać modułu (pracuje w starym standardzie bluetooth). Dodatkowo, ustalcie z innymi uczestnikami kiedy kto uruchamia przykład. W przeciwnym razie, trudno będzie połączyć się z odpowiednim.\nPobierz ze sklepu play aplikację bluetooth serial terminal. Po jej uruchomieniu połącz się z modułem. Dane które wyślesz, zostaną odesłane do telefonu.\nHC-05 To najprostszy z dostępnych modułów. Na rynku dostępne jest wiele bardziej zaawansowanych układów. Możesz użyć je do:\n Zdalnego ustawiania parametrów (włączanie diod, sterowanie serwomechanizmem) Zbierania danych z czujników Sterowania urządzeniem (otwieranie zamka, włączanie alarmu itp.)  ","wordCount":"732","inLanguage":"en","datePublished":"2023-02-13T16:41:13+01:00","dateModified":"2023-02-13T16:41:13+01:00","author":{"@type":"Person","name":"Radosław Sajdak"},"mainEntityOfPage":{"@type":"WebPage","@id":"www.hexu.pl/post/uart/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"www.hexu.pl/favicon.ico"}}}</script>
</head>
<body class=dark id=top>
<script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=www.hexu.pl>Home</a>&nbsp;»&nbsp;<a href=www.hexu.pl/post/>Posts</a></div>
<h1 class=post-title>
UART (Universal Asynchronous Receiver-Transmitter)
</h1>
<div class=post-meta><span title="2023-02-13 16:41:13 +0100 CET">February 13, 2023</span>&nbsp;·&nbsp;732 words&nbsp;·&nbsp;Radosław Sajdak
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><nav id=TableOfContents>
<ul>
<li><a href=#uart---komunikacja-z-komputerem>UART - komunikacja z komputerem</a>
<ul>
<li><a href=#czytanie-wiadomości-uart>Czytanie wiadomości UART</a></li>
<li><a href=#decyzje-w-oparciu-o-wiadomości-uart---switch-case>Decyzje w oparciu o wiadomości UART - switch case</a></li>
<li><a href=#uart---transmisja-bluetooth>UART - transmisja bluetooth</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</details>
</div>
<div class=post-content><h1 id=uart-universal-asynchronous-receiver-transmitter>&ldquo;UART (Universal Asynchronous Receiver-Transmitter)&rdquo;<a hidden class=anchor aria-hidden=true href=#uart-universal-asynchronous-receiver-transmitter>#</a></h1>
<p>UART jest jednym z najczęściej stosowanych protokołów komunikacyjnych. Stosuje się go m.in.:</p>
<ul>
<li>W komunikacji między procesorami</li>
<li>Do wyprowadzania tzw. &ldquo;Debugu&rdquo;</li>
<li>Do komunikacji z modułami (Bluetooth, GPS, LTE itp.)</li>
</ul>
<p>Poznaliśmy wcześniej <strong>monitor portu szeregowego</strong>. Jest to nic innego, jak właśnie UART. W ten sposób,
wysyłając bajt po bajcie, czytaliśmy wiadomości wysyłane przez mikroprocesor.</p>
<p>Więcej na temat komunikacji UART, przeczytasz <a href=https://www.analog.com/en/analog-dialogue/articles/uart-a-hardware-communication-protocol.html>tutaj</a>.
Dla nas, najważniejszy jest sposób podłączenia &ldquo;na krzyż&rdquo;:
<img loading=lazy src="https://www.analog.com/-/media/images/analog-dialogue/en/volume-54/number-4/articles/uart-a-hardware-communication-protocol/335962-fig-01.svg?w=900&imgver=1" alt="UART connection">
</p>
<h2 id=uart---komunikacja-z-komputerem>UART - komunikacja z komputerem<a hidden class=anchor aria-hidden=true href=#uart---komunikacja-z-komputerem>#</a></h2>
<h3 id=czytanie-wiadomości-uart>Czytanie wiadomości UART<a hidden class=anchor aria-hidden=true href=#czytanie-wiadomości-uart>#</a></h3>
<p>W rozdziale GPIO, przy użyciu biblioteki <code>Serial</code>, wysyłaliśmy wiadomości do naszego komputera. Korzystając
z tej samej biblioteki, możemy wysyłać wiadomości do mikrokonrolera. Poniższy kod, odbiera bajt po bajcie
wiadomość z naszego portu szeregowego. Działa on w sposób nieblokujący, dzięki użyciu funkcji <code>serialEvent()</code>.
Jej zawartość, można przenieść do funkcji <code>loop()</code> nie zmieniając działania kodu.</p>
<p><strong>UWAGA!</strong> Monitor portu szeregowego, domyślnie wysyła znak nowej linii po naciśnięciu klawisza &ldquo;Enter&rdquo;.
Jest to znak <code>\n</code> który przez systemy operacyjne interpretowany jest jako nowa linia. Z tego powodu, zobaczysz &ldquo;dziwną&rdquo;
przerwę po ostatnim &ldquo;received:&rdquo;.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=cp>#include</span> <span class=cpf>&#34;Arduino.h&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>void</span> <span class=nf>setup</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>Serial</span><span class=p>.</span><span class=n>begin</span><span class=p>(</span><span class=mi>115200</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>serialEvent</span><span class=p>(){</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>Serial</span><span class=p>.</span><span class=n>available</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>char</span> <span class=n>character</span> <span class=o>=</span> <span class=n>Serial</span><span class=p>.</span><span class=n>read</span><span class=p>();</span>
    <span class=n>Serial</span><span class=p>.</span><span class=n>print</span><span class=p>(</span><span class=s>&#34;received: &#34;</span><span class=p>);</span>
    <span class=n>Serial</span><span class=p>.</span><span class=n>println</span><span class=p>(</span><span class=n>character</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>loop</span><span class=p>()</span>
<span class=p>{</span>

<span class=p>}</span>

</code></pre></div><p>Zazwyczaj, interesuje nas jednak reakcja kodu na całą komendę, a nie pojedynczy znak (choć nie zawsze).
Biblioteka <code>String.h</code>, pozwala na operacje na ciągach znaków w bardzo intuicyjny sposób. Spróbuj:</p>
<ul>
<li>Utworzyć zmienną globalną typu <code>String</code> o nazwie <code>inputString</code></li>
<li>Dodawać do niej każdy odebrany bajt (tip. <code>a += 1</code> to to samo co <code>a = a + 1</code>)</li>
<li>Jeżeli bajt jest równy (<code>==</code>) znakowi nowej linii (<code>\n</code>) wyprintuj zawartość <code>inputString</code></li>
<li>Przypisz do <code>inputString</code> wartość <code>""</code> (wyzeruj)</li>
</ul>
<link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=serial_read_byte type=checkbox>
<pre><code class=language-c>
#include "Arduino.h"

String inputString;

void setup()
{
    Serial.begin(115200);
}


void serialEvent()
{
    if (Serial.available() > 0) 
    {
        char character = Serial.read();
        inputString += character;
        if(character == '\n')
        {
            Serial.print("received: ");
            Serial.println(inputString);
            inputString = "";
        }
    }
}

void loop()
{

}

</pre></code>
<label for=serial_read_byte class=spoiler-button>Pokaż rozwiązanie
</div>
</figure>
<h3 id=decyzje-w-oparciu-o-wiadomości-uart---switch-case>Decyzje w oparciu o wiadomości UART - switch case<a hidden class=anchor aria-hidden=true href=#decyzje-w-oparciu-o-wiadomości-uart---switch-case>#</a></h3>
<p>W zależności od aplikacji, możemy chcieć wykonywać różne instrukcje w oparciu o wiadomości przyjęte
na UART. Możemy zrobić to przy użyciu instrukcji <code>switch([zmienna]) case [wariant]</code>. Pozwala ona wykonywać
instrukcje w zależności od argumentu. Działa ona podobnie do drabinki instrukcji if&mldr;</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=k>switch</span><span class=p>(</span><span class=n>zmienna</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>case</span> <span class=sc>&#39;a&#39;</span><span class=o>:</span>
        <span class=n>move_left</span><span class=p>();</span>
        <span class=k>break</span><span class=p>;</span>

    <span class=k>case</span> <span class=sc>&#39;s&#39;</span><span class=o>:</span>
        <span class=n>move_down</span><span class=p>();</span>
        <span class=k>break</span><span class=p>;</span>
    
    <span class=k>default</span><span class=o>:</span>
        <span class=n>do_not_move</span><span class=p>();</span>
        <span class=k>break</span><span class=p>;</span>

<span class=p>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=k>if</span> <span class=p>(</span><span class=n>zmienna</span> <span class=o>==</span> <span class=sc>&#39;a&#39;</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>move_left</span><span class=p>();</span>
<span class=p>}</span>
<span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>zmienna</span> <span class=o>==</span> <span class=sc>&#39;s&#39;</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>move_down</span><span class=p>();</span>
<span class=p>}</span>
<span class=k>else</span>
<span class=p>{</span>
    <span class=n>do_not_move</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><p>Obydwa powyższe fragmenty, realizują <strong>dokładnie tę samą logikę</strong>, jednak instrukcja <code>switch</code> jest szybsza
i zdecydowanie bardziej czytelna. Szczególnie, gdy &ldquo;gałęzi&rdquo; jest wiele.</p>
<p>Bardzo ważne w instrukcji switch() jest zamknięcie przypadku (case) słowem <code>break</code>. W przeciwnym razie,
mikrokontroler wywoła wszystkie instrukcje do napotkania pierwszego <code>break</code>.</p>
<p>Spróbuj w naszym wcześniejszym kodzie zaimplementować &ldquo;sterowanie&rdquo; klawiszami <strong>wsad</strong> przy użyciu instrukcji
<code>switch</code>.</p>
<ul>
<li>Czytaj jeden bajt z &ldquo;Seriala&rdquo;</li>
<li>&ldquo;Printuj&rdquo; odpowiednio &ldquo;UP&rdquo;, &ldquo;DOWN&rdquo;, &ldquo;LEFT&rdquo;, &ldquo;RIGHT&rdquo; w zależności od wciśniętego przycisku.</li>
<li>(Opcjonalne) obsłuż zarówno małe jak i wielkie litery (tip. czasem można celowo pominąć <code>break</code>)</li>
</ul>
<link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=serial_read_switch type=checkbox>
<pre><code class=language-c>
#include "Arduino.h"

void setup()
{
    Serial.begin(115200);
}


void serialEvent()
{
    if (Serial.available() > 0) 
    {
        char character = Serial.read();
        switch(character) 
        {
            case 'w':
            case 'W':
                Serial.println("UP!");
                break;

            case 's':
            case 'S':
                Serial.println("DOWN!");
                break;

            case 'a':
            case 'A':
                Serial.println("LEFT!");
                break;

            case 'd':
            case 'D':
                Serial.println("RIGHT!");
                break;
        }
    }
}

void loop()
{

}

</pre></code>
<label for=serial_read_switch class=spoiler-button>Pokaż rozwiązanie
</div>
</figure>
<h3 id=uart---transmisja-bluetooth>UART - transmisja bluetooth<a hidden class=anchor aria-hidden=true href=#uart---transmisja-bluetooth>#</a></h3>
<p>Jak wspomniałem na początku tego rozdziału, UART może służyć do obsługi modułów bezprzewodowych. Przykładem jednego z nich jest
<code>HC-05</code>. Pozwala on na stworzenie bezprzewodowego monitora portu szeregowego, a następnie sterowania mikrokontrolerem z poziomu np. telefonu.
Wgraj na swój mikrokontroler poniższy kod. Realizuje on funkcję &ldquo;echo&rdquo;, czyli zwraca na port szeregowy to, co zostanie do niego wysłane. Zwróć uwagę, że prędkość transmisji wynosi <code>9600</code>!</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=cp>#include</span> <span class=cpf>&#34;Arduino.h&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>void</span> <span class=nf>setup</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>Serial</span><span class=p>.</span><span class=n>begin</span><span class=p>(</span><span class=mi>9600</span><span class=p>);</span>
<span class=p>}</span>


<span class=kt>void</span> <span class=nf>serialEvent</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>Serial</span><span class=p>.</span><span class=n>available</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> 
    <span class=p>{</span>
        <span class=kt>char</span> <span class=n>character</span> <span class=o>=</span> <span class=n>Serial</span><span class=p>.</span><span class=n>read</span><span class=p>();</span>
        <span class=n>Serial</span><span class=p>.</span><span class=n>write</span><span class=p>(</span><span class=n>character</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>loop</span><span class=p>()</span>
<span class=p>{</span>

<span class=p>}</span>
</code></pre></div><p>Następnie, podłącz moduł bluetooth zgodnie z poniższym schematem</p>
<link rel=stylesheet href=../../stylesheets/spoiler.css>
<figure>
<div class=spoiler>
<input id=hc-05-connect type=checkbox>
<img src=images/hc-05-connect.png>
<label for=hc-05-connect class=spoiler-button>Pokaż rozwiązanie
</div>
</figure>
<p>Uruchom na swoim telefonie bluetooth i sparuj urządzenie <code>HC-05</code>. <strong>UWAGA</strong> Niektóre telefony mogą nie wykrywać modułu (pracuje w starym standardzie bluetooth). Dodatkowo, ustalcie z innymi uczestnikami kiedy kto uruchamia przykład. W przeciwnym razie, trudno będzie połączyć się z odpowiednim.</p>
<p>Pobierz ze sklepu play aplikację <code>bluetooth serial terminal</code>. Po jej uruchomieniu połącz się z modułem. Dane które wyślesz, zostaną odesłane do telefonu.</p>
<p><img loading=lazy src=images/BT_terminal.png alt=bt_terminal>
</p>
<p><code>HC-05</code> To najprostszy z dostępnych modułów. Na rynku dostępne jest wiele bardziej zaawansowanych układów. Możesz użyć je do:</p>
<ul>
<li>Zdalnego ustawiania parametrów (włączanie diod, sterowanie serwomechanizmem)</li>
<li>Zbierania danych z czujników</li>
<li>Sterowania urządzeniem (otwieranie zamka, włączanie alarmu itp.)</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
</ul>
<nav class=paginav>
<a class=prev href=www.hexu.pl/post/gpio/>
<span class=title>« Prev</span>
<br>
<span>GPIO</span>
</a>
<a class=next href=www.hexu.pl/post/i2c/>
<span class=title>Next »</span>
<br>
<span>I2C - Wyświetlacz OLED</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2023 <a href=www.hexu.pl></a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>